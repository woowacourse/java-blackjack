# java-blackjack

블랙잭 미션 저장소

## 우아한테크코스 코드리뷰

- [온라인 코드 리뷰 과정](https://github.com/woowacourse/woowacourse-docs/blob/master/maincourse/README.md)

---

# 용어 정리

- 힛(hit): 카드를 더 받는다
- 스탠드(stand): 카드를 더 받지 않는다
- 버스트(bust): 기준점수(21점)를 초과한 상태를 의미
- 푸시(push): 딜러와 플레이어 카드 점수가 동점일 때를 의미
- 블랙잭(blackjack): Ace 한장과 10에 해당하는 패(10, J, Q, K)로 21점을 만드는 것을 의미

---

# 구현 기능 목록 - 2단계

## 입력

### 베팅 금액

-[x] 플레이어별로 베팅 금액을 정한다
    - [x] 금액은 숫자이어야한다
    - [x] 금액은 1000원 단위로 입력할 수 있다.

## 출력

### 최종 수익

- [x] 게임을 완료한 후 각 플레이어별로 최종 수익을 출력한다

```text
<출력 예시>
## 최종 수익
딜러: 10000
pobi: 10000 
jason: -20000
```

## 기능

### 수익계산

- [x] 카드를 추가로 뽑아 21을 초과할 경우 플레이어는 배팅 금액을 모두 잃는다
- [x] 처음 두 장의 카드 합이 21으로 블랙잭이 되면 베팅 금액의 1.5배를 딜러에게 받는다
- [x] 딜러와 플레이어가 모두 동시에 블랙잭인 경우 플레이어는 베팅한 금액을 돌려받는다
- [x] 딜러와 플레이어의 점수가 21점을 넘지 않으면서 같은 경우 플레이어는 베팅한 금액을 돌려받는다
- [x] 딜러가 21점을 초과하면 그 시점까지 남아있던 플레이어는 가지고 있는 패에 상관없이 승리해 베팅 금액을 받는다
- [x] 딜러와 플레이어의 점수가 21점을 넘지 않으면서 플레이어 점수가 높은 경우 플레이어는 승리해 베팅 금액을 받는다

---

# 구현 기능 목록 - 1단계

## 입력

### 참여자

- [x] 참여자를 입력받는다
    - [x] 쉼표를 기준으로 구분한다
    - [x] 공백은 허용하지 않는다
    - [x] 구분자로 끝나지 않는다

### 카드수령

- [x] n 또는 y로 입력한다
    - [x] y이면 n을 입력할때까지 계속해서 입력받는다

---

## 출력

### 초기 카드 지급

- [x] 딜러의 카드는 한장만 공개한다
- [x] 참여자의 카드는 두장 모두 공개한다
    - [x] 구분자는 ", "이다

```text
<출력 예시>
딜러와 pobi, jason에게 2장을 나누었습니다.
딜러: 3다이아몬드
pobi카드: 2하트, 8스페이드
jason카드: 7클로버, K스페이드
```

### 최종 카드 지급

- [x] 딜러, 참여자별로 가지고 있는 카드와 점수를 출력한다

```text
<출력 예시>
딜러 카드: 3다이아몬드, 9클로버, 8다이아몬드 - 결과: 20
pobi카드: 2하트, 8스페이드, A클로버 - 결과: 21
jason카드: 7클로버, K스페이드 - 결과: 17
```

### 최종 승패

- [x] 게임을 완료한 후 각 플레이어별로 승패를 출력한다

```text
<출력 예시>
## 최종 승패
딜러: 1승 1패
pobi: 승 
jason: 패
```

---

## 기능

### 카드지급

- [x] 카드는 모양과 숫자가 모두 다른 52장 한벌을 사용한다
- [x] 게임을 시작하면 딜러와 플레이어는 각각 두 장의 카드를 지급 받는다
    - [x] 문양과 숫자를 각각 랜덤으로 선택하여 카드를 조합한다
- [x] 블랙잭이면 추가 카드를 지급받지 않고 턴이 종료된다.
- [x] 플레이어는 21을 넘지 않을 경우 원한다면 얼마든지 카드를 계속 뽑을 수 있다
    - [x] 21을 넘으면 메세지 출력 후 턴이 종료된다
- [x] 여러 덱을 사용하므로 중복 카드가 발급될 수 있다
- [x] 딜러의 카드 추가 발급은 현재 가지고있는 점수에 따라 결정된다
    - [x] 처음에 받은 2장의 합계가 16이하이면 반드시 1장의 카드를 추가로 받아야 한다
    - [x] 처음에 받은 2장의 합계가 17점 이상이면 추가로 받을 수 없다

### 점수계산

- [x] 카드의 점수 계산은 카드 숫자를 기본으로 한다
- [x] King, Queen, Jack은 각각 10으로 계산한다
- [x] Ace는 1 또는 11로 계산할 수 있다
    - [x] Ace가 있을 경우 1로 계산한 뒤 합산 점수가 11 이하이면 10을 더해준다

### 게임규칙

- [x] 딜러와 참여자 각각 카드 점수 합계를 비교하여 승/무/패를 결정한다
    - [x] 가지고 있는 카드 숫자를 합쳐 21을 초과하지 않으면서 21에 가깝게 만들면 이긴다

---

## 고민한 포인트

### 1. 도메인과 DTO 활용

현재 로직은 비즈니스 로직을 거친 도메인을 view로 넘겨주고 있습니다.<br>
그래서 view에서 도메인의 정보를 getter를 통해 가져와서 출력하고 있습니다. MVC패턴에서 view는 도메인을 몰라야하는것이 아닌가하는 생각이 들었습니다.<br>
view에서 필요한 정보만 DTO에 담아서 전달해주어야하지 않을까 생각되는데 그러다보면 또 너무 많은 DTO가 생기게 될것 같아서 어떻게 해야할지 고민됩니다.<br>
ex. (현재) Card를 view로 가져와서 card.getCardNumber().getText()로 사용 -> (변경) CardDto를 사용해 카드 이름, 숫자만 전달<br>
그런데 이번 미션의 경우 인스턴스 변수 2개라는 제약이 있어 출력 형태에 따라 Card에도 여러개의 DTO가 파생될 수 있을것같습니다.<br>
ex. 똑같은 카드에 대해 3다이아몬드 라는걸 나타내는 Dto, 3점짜리 카드라는걸 나타내는 Dto<br>
-> DTO로 변환해서 전달해주는것이 맞을지, 그리고 이렇게 필요에 따라 다양한 DTO를 활용하는게 맞을지 궁금합니다.<br>
-> 제가 생각한 결론: DTO를 통해서 전달하는것이 의미적으로는 맞다. 그리고 필요한 데이터가 다르다면 같은 도메인이더라도 다른 DTO 를 사용할 수 있다.
그러나 VO와 같이 도메인에서 단순히 값만 전달하는 경우라면(도메인의 특정 필드를 가져와서 변경하지 않고 바로 쓰는 경우) DTO를 쓰지 않고 도메인을 전달하는것이
오히려 관리 포인트를 줄일 수 있을것 같다.

### 2. Enum 사용

카드 모양, 카드 숫자는 지정된 값들이므로 enum으로 관리할 때 이점이 있다고 생각했습니다.<br>
(랜덤 숫자에 따라 해당하는 모양과 숫자를 결정할 수 있고, 해당 숫자에 따른 점수를 반환할 수 있음)<br>
카드 숫자, 모양에 따라 어떻게 출력되어야하는지 '모양'에 대한 특성도 필드로 작성하게 되었습니다.<br>
그런데 이렇게 되면 view와 관련된 특성이 도메인에 있게 되는것이 아닌가 하는 의문이 들었습니다.<br>
-> 만약 출력 형태도 enum으로 관리하고자 하면 해당 부분을 다시 view 부분에 다른 enum으로 두어야할까요?<br>
그렇게 되면 중복코드가 생기게 되는것 같고 현재 위치에 두기에는 view 관련 로직이 도메인에 있는것 같아 고민이 됩니다.

### 3. 추상 클래스 활용

딜러와 플레이어 사이에는 공통 필드, 로직이 있어 해당 부분을 추상클래스로 분리하였습니다.<br>
참여자 - 딜러/플레이어 는 is-a 관계이고 공통된 필드와 메서드를 사용할 수 있어서 상속을 활용하는것이 적절하다고 생각했습니다.<br>
받은 카드들의 목록, 카드를 받는 행위는 공통적인 부분이라고 생각해 상위 클래스에서 작성하고
카드를 추가로 받을 수 있는지 / 없는지 구분하는 기준 점수는 딜러와 플레이어가 다르므로 하위 클래스에서 각각 구현하도록하였습니다.

### 4. 카드 인스턴스 캐싱하기

카드가 생성될 수 있는 경우의수는 총 52가지이다.(카드 숫자 13종류 * 카드 모양 4종류)<br>
카드를 뽑을 때 매번 새로운 카드 인스턴스를 생성하지 않고 캐싱되어있는 카드 목록에서 해당 카드를 뽑아서 전달할 수 있다<br>
캐시(Cache): 애플리케이션이나 장치에 접근할 때 검색 시간과 노력을 줄이기 위해 정보(데이터)를 일시적으로 저장하는 장소<br>
캐싱(Caching): 데이터를 캐시에 저장하거나 사용하는 등 캐시를 사용하는 행위<br>
-> 애플리케이션 시작시 카드덱 전체를 캐싱해놓고 해당되는 카드를 전달하는 방식을 적용했습니다.
