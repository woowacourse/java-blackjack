# java-blackjack

# 목표

- 플레이어, 딜러의 중복 코드 제거
- 책임 잘 분배하기(기능을 해치지 않는 선에서 책임과 해야하는 일이 명확한 코드)
- TDD - 요구사항 분석을 잘해서 도메인에 대한 이해는 다 하고 시작.
  (설계를 하는 시간은 최소화)
  최소 단위로 테스트를 작성하면서 더 작은 단위가 나오면 그 테스트를 구현하고, 그러면서도 자연스럽게 설계가 좋게 나오게
  (이번에는 TDD 사이클단위로 커밋을 남기지는 않으려 합니다)
- 시간내에 제출

# 요구사항

- [X] 딜러는 처음에 받은 2장의 합계가 16이하이면 반드시 1장의 카드를 추가로 받아야 하고, 17점 이상이면 추가로 받을 수 없다.
    - [X] 1장의 카드를 받은 뒤에도 16이하인 경우 16 초과가 될때까지 추가로 받는다
- [x] 게임을 시작하면 플레이어는 두 장의 카드를 지급 받으며, 두 장의 카드 숫자를 합쳐 21을 초과하지 않으면서 21에 가깝게 만들면 이긴다. 21을 넘지 않을 경우 원한다면 얼마든지 카드를 계속 뽑을 수
  있다.
    - [X] 카드의 합이 21인 경우에도 더 받을지 묻는다
- [X] 버스트시에는 다시 묻지 않는다
- [x] 게임을 완료한 후 각 플레이어별로 승패를 출력한다.
    - [x] 승 패는 플레이어 vs 딜러인 상황에서 판정한다
    - [x] 무승부인 경우 승과 패 둘다 아닌것으로 계산한다(플레이어에게는 무승부라고 출력됨)

- [x] 플레이어 수는 2-8명으로 제한한다.(딜러포함)
- [X] 카드가 부족하면 예외가 발생한다

- [x] 플레이어는 카드를 받을 수 있다
    - [x] 플레이어는 카드의 합이 21이하인 경우 카드를 받을 수 있다
    - [x] 카드의 합이 21이 넘은 경우 더 이상 받을 수 없다


# 질문

## 캡슐화 vs 중복 코드 제거

이번 미션의 목표로는

- `딜러와 플레이어에서 발생하는 중복 코드를 제거해야 한다.` 가 있었습니다.   
  이를 해결하기 위해서 **추상클래스**로 상속하였고, 일부분 해소되었습니다.
- 그런데 딜러와 플레이어에게 카드를 주는 행위는, 현재 만들어진 책임을 깨지 않는 선에서는잘 해결이 되지 않았습니다.

```java
            blackjackParticipants.addDealerCard(deck.drawCard());
            public void drawCard(String name) {
              blackjackParticipants.addCard(name, deck.drawCard());
            }
```

코드에는 플레이어와 딜러 객체가 서로 비슷한 부분이 있음에도 불구하고 추가하는 메서드를 개별적으로 가지고 있습니다. 위 코드가 중복 코드라고 보고 개선을 해보려고 하였습니다.


##### 방법 1

```java
public void drawCard(BlackjackPlayer blackjackPlayer) {
  blackjackPlayer.addCard(deck.drawCard());
}
```

위 코드의 경우 외부에서 BlackjackPlayer를 가지고 있게 되고, blackjackPlayer에 대한 관리까지 외부에서 해야합니다. 이 경우 캡슐화가 깨졌다고 생각합니다.

##### 방법 2 

- DEALER에게 `"딜러"`라는 식별 이름 부여하여 players 컬렉션에 포함시키기
- 위 방법은 players에 왜 딜러가 있어야하지?라는 의문과 함께,외부에서 "딜러"라는 이름을 통해 내부에서 처리한다는 것을 이해해야하는 단점이 있었습니다.

### 결론

- 위 2가지 방법을 적용하지 않고 캡슐화가 가장 잘 되어있는 기존 코드를 유지하기로 결정하였습니다.      
  캡슐화라는 가치는 객체지향에서 꽤 높은 우선순위라고 생각하는 편입니다.(책임이 잘 분배되었는지도 판단할 수 있다고 생각합니다)   
  위 부분은 뭔가 구현을 잘해서 해결할 수 있는 방법은 아닌것 같아 리뷰어분에게 꼭 물어봐야겠다고 생각하였습니다!
  
---

## 테스트 관련

- 추상 클래스나 상속같은 관계에서 코드를 재사용하기 떄문에 테스트가 중복되는 경우가 많다고 생각합니다. 이번 미션에서는 테스트가 설계서라는 측면에서 둘 다 동일한 동작을 보증하기 위해 테스트를 중복되게 작성을 했습니다.
  이 경우 테스트에서는 중복코드가 생기는 것이 마음에 걸렸는데, 이렇게 테스트 코드를 중복되더라도 두는 것이 좋을 지, 아니면 하나의 테스트 코드만 두는 것이 좋은 지 궁금합니다. 

## 협력 관계를 포함하는 테스트 vs 기능만을 테스트
- 블랙잭 승패 계산에 대한 테스트 코드에서 다음과 같은 내용이 있었습니다.
```java
    @Test
    void 블랙잭_승패_계산() {
        ...
        BlackjackResult blackjackDealerResult = blackjackGame.currentDealerBlackjackResult(); // <<<<<
        List<BlackjackResult> blackjackPlayerResults = blackjackGame.currentPlayerBlackjackResult();
        BlackjackWinner blackjackWinner = new BlackjackWinner(blackjackDealerResult, blackjackPlayerResults);
        ...
    }
```

위 코드는 블랙잭 결과로 승패를 계산하는 로직을 테스트하는 코드입니다.
블랙잭 승패 계산에서는 BlackjackResult라는 객체를 이용하여 승패를 계산합니다. 
1. **실제 애플리케이션에서 사용되는 객체**를 이용하여 BlackjackResult를 생성 - 기존의 코드를 사용하여 테스트 할 수 있습니다.
2. BlackjackResult를 **직접 생성** - 승패 계산 기능만을 테스트 할 수 있습니다.

협력 관계를 포함하여 테스트해야 하는지, 아니면 그 기능만을 테스트해야 하는건지 궁금합니다.

---

## 방어적 api 설계

1. 방어적 설계(Defensive Design)에 대한 고민

일반적인 흐름에서는 문제가 발생하지 않지만, 방어적인 API 설계를 고려하여 예외 처리를 구현했습니다.
```java
public interface DrawStrategy {

    TrumpCard draw(Deque<TrumpCard> trumpCards);
    
    void validateDraw(Deque<TrumpCard> trumpCards); // < 현재 코드에서는 발생할 일이 없음
}
```

예를 들어, drawStrategy의 경우 실제 게임에서는 deck이 빌 일이 없지만, 예외 처리를 추가하여 대비했습니다.
일반적인 로직만 고려하는 설계와 방어적 설계를 적용하는 방식 중 항상 방어적 설계를 적용하는 것이 더 좋은 선택일까요?


예외 처리를 통한 코드의 명확성 향상 여부

아래 코드에서 dealerCards()는 생성자에서 값이 초기화되므로, 카드가 비어 있는 상황이 절대 발생하지 않습니다.
```java 
public TrumpCard dealerCardFirst() {
    return dealerCards().get(0); // << 만약 dealerCards가 비어있다면?
}
```
하지만, 의도를 더욱 명확히 하기 위해 예외 처리를 추가하는 것이 좋을지 고민됩니다.
예외 처리를 추가하면 코드의 안전성이 높아질까요, 아니면 불필요한 오버헤드가 될까요?
이 경우 의도를 드러내는 코드와 방어적 설계 간의 적절한 균형을 어떻게 맞춰야 할까요?


