# java-blackjack

블랙잭 미션 저장소

# 학습목표

- 클린 코드하기
    - 코드 가독성
    - 예측 가능한 코드
    - 불변성/방어적 복사로 실수를 방지하는 코드

## 개인 목표

- 확실하게 TDD 적용하기
    - 테스트 작성 중 작은 기능으로 나뉠 때 우선 작성하던 테스트 및 끝마친다.
    - 그리고 리펙터링 과정에서 테스트를 추가한다.
      (혹 Green케이스 커밋에 나뉜 작은 테스트를 함께 첨부한다.)
- 객체 책임 구분 잘하기
    - 각 객체들의 응집도가 잘 관리되었는가?
    - 중복 코드를 어떻게 제거하였는가?

---

# 기능 흐름

1. [x] 딜러가 참가자 이름 입력 받는다.
2. [x] 각 참가자의 배팅금을 입력 받는다.
3. [x] 게임을 시작하면 딜러와 각각의 플레이어는 두 장의 카드를 지급받는다.
    1. 덱은 딜러에게 2장의 카드를 지급한다.
    2. 덱은 플레이어들에게 2장의 카드를 지급한다.
4. [x] 딜러와 참가자들의 카드를 출력한다.
    1. 딜러는 첫 번째 카드만 출력한다.
    2. 참가자들의 카드를 출력한다.
5. [x] 참가자 순으로 “카드 더받기”를 진행한다.
    1. 참가자의 카드 합이 21점이 넘는지 물어봅니다.
    2. 만약, 참가자의 카드가 21점을 넘지 않는다면, 뽑을지 여부를 입력받습니다.
    3. 뽑을지 여부가 y라면, 참가자는 덱으로부터 카드를 한 장 뽑습니다.
    4. 위의 과정을, 모든 참가자가 n라고 하거나, 누구도 카드 합 21점 이하에 해당하지 않은 경우까지 반복합니다.

    - 카드 더 받기는 참가자에게 카드를 더 받을지 요청받습니다.
    - y라면 카드를 뽑고, 전체 카드 목록을 출력합니다.
    - n이라면 다음 참가자의 “카드 더 받기”가 진행됩니다.
    - 21을 초과하지 않았다면 “카드 더 받기”를 진행할 수 있다.
6. [x] “카드 더 받기”가 종료된 후, 딜러 카드의 합이 16 이하라면, 딜러는 카드를 한 장 뽑는다.
    1. 딜러에게 카드 합이 16 이하인지 물어본다.
    2. 만약, 16 이하라면, 딜러는 카드를 한 장 뽑는다.
        - 이 경우, A는 11로 계산하고, 만약 총 합이 21 초과라면, 이때는 1로 계산한다.
7. [x] 딜러의 카드합이 17이상이면 카드를 더 뽑을 수 없다.
8. [x] 딜러의 카드들과 카드 합을 출력한다.
9. [x] 참가자들의 카드들과 카드 합을 출력한다.
10. [x] 최종 수익을 출력한다.

### 기능 목록

- [x] 중복 없는 모든 카드를 포함한 카드 뭉치 생성
- [x] 카드 지급
- [x] 딜러는 16점 이하일 경우, 카드 무조건 받기
    - 딜러의 카드 합을 계산하는 규칙
        - 모든 카드의 합을 더한다.
        - 만약, A가 존재하고 21점을 초과하면, A를 1로 치환한다.
        - 만약, A가 여러장이라면, 21점을 초과하지 않을 때까지 A를 1로 치환한다.
- [x] 플레이어는 카드 21점 이하일경우 더 받기 여부 체크
- [x] 승패 계산
- [x] 카드 점수 계산
- [x] 수익률 계산

# 중복 코드에 대한 제너릭 기반 컴포지션 활용

## 설계 개요

이 블랙잭 게임 구현은 Participants에 대한"내부의 개별 객체, 외부의 다형성"이라는 설계 철학에 기반한 제너릭 컴포지션 패턴을 사용합니다.

## 핵심 설계 원칙

우리의 블랙잭 게임 구현은 다음과 같은 핵심 원칙에 기반합니다:

1. **역할과 참여자의 분리**: 게임에서의 역할(딜러, 플레이어)과 이를 수행하는 참여자를 명확히 분리합니다.
2. **타입 안전성**: 컴파일 시간에 타입 오류를 발견할 수 있도록 제너릭을 활용합니다.
3. **Participants 캡슐화**: 내부적으로는 구체적인 타입 정보를 활용하고, 외부로는 다형적 인터페이스를 제공합니다.
4. **불변성**: 상태 변경이 필요할 때마다 새로운 객체를 생성하여 불변성을 유지합니다. Getter 사용이 도메인에 영향을 주지 않도록 합니다.
